# Lark Messager

A Rust-based Lark (Feishu) messaging bot API service that provides secure message sending capabilities with unified user-scoped HMAC authentication.

## Features

- **Unified Auth**: User-scoped HMAC API keys with timestamp/nonce verification
- **Lark Integration**: Send messages to users and groups via Lark Bot API
- **Message Validation**: Verify recipient existence before sending
- **Comprehensive Logging**: Request logging, error tracking, and debug information
- **Auditable History**: Filterable operation and message logs for post-event reviews
- **Docker Support**: Containerized deployment with Docker Compose
- **Database Support**: MySQL with automatic migrations
- **Rate Limiting Ready**: Architecture supports rate limiting implementation

## Quick Start

### Prerequisites

- Rust 1.75+ 
- Lark App credentials (App ID and App Secret)
- MySQL 8.0+ database

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd lark_messager
```

2. Copy environment configuration:
```bash
cp .env.example .env
```

3. Update `.env` with your Lark App credentials and first-deployment flag:
```env
LARK_APP_ID=your-lark-app-id
LARK_APP_SECRET=your-lark-app-secret
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
FIRST_DEPLOYMENT=true
```

4. Initialise the database schema (one-time):
```bash
cargo run --bin init_system
```
This command checks `FIRST_DEPLOYMENT`; when the flag is `true` it applies all migrations and seeds a default `super_admin` user with the temporary password `ChangeMe123!`. After the command succeeds, set `FIRST_DEPLOYMENT=false` (or remove the variable) to prevent re-running the seed logic.

5. Start the API server:
```bash
cargo run
```
The server listens on `http://localhost:8080` by default. Ensure migrations have already been applied (via `init_system` or another migration tool) before starting the API.

6. Sign in as the seeded super admin, rotate the password, and create additional accounts:
```bash
# 6a. Obtain a JWT session token using the seeded credentials
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "super_admin", "password": "ChangeMe123!"}'

# 6b. Decode the JWT payload to find the `sub` field (your user UUID) and change the password immediately
#     You can paste the token into https://jwt.io or use any JWT tool to inspect the payload.
#     Then call:
# curl -X PATCH http://localhost:8080/auth/users/<SUPER_ADMIN_ID>/password \
#   -H "Authorization: Bearer <jwt_token>" \
#   -H "Content-Type: application/json" \
#   -d '{"current_password":"ChangeMe123!","new_password":"<new password>"}'

# 6c. Create additional admins or regular users (super admin can set "is_admin": true)
# curl -X POST http://localhost:8080/auth/users \
#   -H "Authorization: Bearer <jwt_token>" \
#   -H "Content-Type: application/json" \
#   -d '{"username":"ops-admin","password":"S3curePass!","is_admin":true}'

# 6d. Create an API key scoped to the logged-in user
curl -X POST http://localhost:8080/auth/api-keys \
  -H "Authorization: Bearer <jwt_token>" \
  -H "Content-Type: application/json" \
  -d '{"name": "local-dev", "rate_limit_per_minute": 30}'
```
Record the returned `secret` immediately; it is only shown once. Use the `/auth/api-keys` suite to list, disable, delete, or reset failure counts as needed.

### Docker Deployment

The container entrypoint executes the same initialisation command when `FIRST_DEPLOYMENT=true`. Set the flag for the very first rollout, then switch it to `false` (or remove it) before restarting containers.

1. Build and start with Docker Compose:
```bash
docker-compose up -d
```

2. Check service health:
```bash
curl http://localhost:8080/health
```

## API Documentation

### Authentication

#### Session Authentication (JWT)
Use `/auth/login` with a username/password to obtain a short-lived JWT for managing API keys and configuration. Supply the token in `Authorization: Bearer <token>` when calling management endpoints.

Tokens expire 30 minutes (1800s) after issue. Calling `/auth/token/extend` refreshes the session by another 30 minutes from the later of the current expiry or now; it does not stack additional time beyond that window.

#### Signed API Requests (HMAC)
Runtime calls to messaging endpoints must include the following headers:

- `X-Lark-Access-Key`: UUID of the API key
- `X-Lark-Timestamp`: UNIX seconds generated by the caller
- `X-Lark-Nonce`: unique nonce per request within the 5-minute window
- `X-Lark-Signature`: hex-encoded HMAC-SHA256 signature

The signature canonically signs the string:
```
<timestamp>
<nonce>
<HTTP_METHOD>
<path_with_query>
```
using the API key secret. Example with `openssl`:
```bash
TIMESTAMP=$(date -u +%s)
NONCE=$(uuidgen | tr 'A-Z' 'a-z')
CANONICAL="$TIMESTAMP
$NONCE
POST
/messages/send"
SIGNATURE=$(printf "%s" "$CANONICAL" | openssl dgst -sha256 -hmac "$API_KEY_SECRET" -hex | awk '{print $2}')
```
Requests older than 5 minutes or with duplicated nonces are rejected and increase the key's failure count. Exceeding the configured threshold automatically disables the key.

### Endpoints

#### Health Check
```bash
GET /health
```

#### Authentication
```bash
POST /auth/login                     # Obtain JWT session token
GET  /auth/api-keys                  # List API keys owned by the session user
POST /auth/api-keys                  # Create an API key for the session user
PATCH /auth/api-keys/{id}/status     # Enable or disable an API key
PATCH /auth/api-keys/{id}/rate-limit # Adjust per-minute rate limit
POST /auth/api-keys/{id}/reset-failures # Reset failure counter for an API key
DELETE /auth/api-keys/{id}           # Permanently delete an API key
GET  /auth/configs                   # Inspect authentication-related configs (admin only)
PATCH /auth/configs                  # Update authentication-related configs (admin only)
```

#### Messages
```bash
POST /messages/send                  # Send message to user (HMAC headers required)
POST /messages/send-group            # Send message to group (HMAC headers required)
POST /recipients/verify              # Verify recipient exists (HMAC headers required)
POST /messages/logs/query            # Filter message delivery history (JWT required)
POST /audit/operation-logs/query     # Filter admin/user actions (JWT required, admin only)
```

#### Log Query Payloads
Both log-query endpoints accept a JSON body with optional filters. Omitting a field removes that filter; empty payloads return the most recent entries (default limit 100, max 1000).

`/messages/logs/query` fields:

- `sender_id` (UUID) – API key ID that initiated the message
- `sender_name` (string) – API key friendly name (auto-resolves to `sender_id`)
- `owner_username` (string) – owner username; non-admins default to their own account
- `status` (string) – delivery status, e.g. `sent` / `failed`
- `sender_type` (string) – e.g. `api_key`
- `start_time` / `end_time` (RFC3339) – timestamp window for `timestamp`
- `limit` (int) – number of results (1–1000, default 100)

`/audit/operation-logs/query` fields (admin only):

- `username` (string) – actor username
- `operation_type` (string) – e.g. `user.create`, `api_key.delete`
- `start_time` / `end_time` (RFC3339)
- `limit` (int)

### Example Usage

#### Send Message with Signed Headers
```bash
TIMESTAMP=$(date -u +%s)
NONCE=$(uuidgen | tr 'A-Z' 'a-z')
CANONICAL="$TIMESTAMP
$NONCE
POST
/messages/send"
SIGNATURE=$(printf "%s" "$CANONICAL" | openssl dgst -sha256 -hmac "$API_KEY_SECRET" -hex | awk '{print $2}')

curl -X POST http://localhost:8080/messages/send \
  -H "X-Lark-Access-Key: $API_KEY_ID" \
  -H "X-Lark-Timestamp: $TIMESTAMP" \
  -H "X-Lark-Nonce: $NONCE" \
  -H "X-Lark-Signature: $SIGNATURE" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient": "user@example.com",
    "message": "Hello from Lark Messager!",
    "recipient_type": "email"
  }'
```

#### Verify Recipient
```bash
TIMESTAMP=$(date -u +%s)
NONCE=$(uuidgen | tr 'A-Z' 'a-z')
CANONICAL="$TIMESTAMP
$NONCE
POST
/recipients/verify"
SIGNATURE=$(printf "%s" "$CANONICAL" | openssl dgst -sha256 -hmac "$API_KEY_SECRET" -hex | awk '{print $2}')

curl -X POST http://localhost:8080/recipients/verify \
  -H "X-Lark-Access-Key: $API_KEY_ID" \
  -H "X-Lark-Timestamp: $TIMESTAMP" \
  -H "X-Lark-Nonce: $NONCE" \
  -H "X-Lark-Signature: $SIGNATURE" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient": "user@example.com",
    "recipient_type": "email"
  }'
```

#### Query Message History
```bash
JWT=$(curl -s -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"ops-admin","password":"S3curePass!"}' | jq -r '.token')

curl -X POST http://localhost:8080/messages/logs/query \
  -H "Authorization: Bearer $JWT" \
  -H "Content-Type: application/json" \
  -d '{
        "sender_name": "local-dev",
        "status": "sent",
        "start_time": "2025-09-20T00:00:00Z",
        "end_time": "2025-09-25T23:59:59Z",
        "limit": 50
      }'
```

#### Query Operation Logs (Admin)
```bash
curl -X POST http://localhost:8080/audit/operation-logs/query \
  -H "Authorization: Bearer $JWT" \
  -H "Content-Type: application/json" \
  -d '{
        "username": "ops-admin",
        "operation_type": "api_key.create",
        "start_time": "2025-09-24T00:00:00Z",
        "limit": 20
      }'
```

## Configuration

### Environment Variables

| Variable | Description | Default | Required |
|----------|-------------|---------|----------|
| `DATABASE_URL` | MySQL database connection URL | `mysql://root:password@localhost:3306/lark_messager` | No |
| `JWT_SECRET` | JWT signing secret | - | Yes |
| `LARK_APP_ID` | Lark application ID | - | Yes |
| `LARK_APP_SECRET` | Lark application secret | - | Yes |
| `SERVER_HOST` | Server bind address | `127.0.0.1` | No |
| `SERVER_PORT` | Server port | `8080` | No |
| `LOG_LEVEL` | Logging level | `info` | No |
| `FIRST_DEPLOYMENT` | Indicates first rollout; entrypoint/init command runs bootstrap when true | `false` | No |
| `API_KEY_LENGTH` | Generated API key length | `64` | No |

### Recipient Types

The service supports multiple recipient identification methods:

#### For Individual Messages (`/messages/send`)
- `user_id`: Lark user open_id (obtained from email/mobile lookup)
- `email`: Email address (automatically converted to open_id)
- `mobile`: Phone number (automatically converted to open_id)
- `auto`: Auto-detect based on format (default)

#### For Group Messages (`/messages/send-group`)
- `chat_id`: Group chat ID (oc_xxx, ou_xxx)
- `chat_name`: Group chat name (automatically converted to chat_id)
- `auto`: Auto-detect based on format (default)

## Development

### Running Tests

```bash
# Run all tests
cargo test

# Run specific test
cargo test test_login_success

# Run with output
cargo test -- --nocapture
```

### Database Setup

1. Create a MySQL database:
```sql
CREATE DATABASE lark_messager;
CREATE USER 'lark_user'@'%' IDENTIFIED BY 'lark_password';
GRANT ALL PRIVILEGES ON lark_messager.* TO 'lark_user'@'%';
FLUSH PRIVILEGES;
```

2. Database migrations are automatically applied on startup. Migration files are located in the `migrations/` directory.

Auth data lives in `auth_users` and `auth_api_keys`, while tunable thresholds are stored in `app_configs` (all seeded via `migrations/001_initial.sql`).

### Adding New Features

1. Update models in `src/models.rs`
2. Add database operations in `src/database.rs`
3. Implement handlers in `src/handlers.rs`
4. Add routes in `src/routes.rs`
5. Write tests in `tests/`

## Architecture

### Core Components

- **Web Server**: Axum-based HTTP server
- **Authentication**: User-scoped HMAC API keys with JWT-backed management sessions
- **Database**: MySQL with SQLx ORM
- **Lark Client**: HTTP client for Lark Bot API
- **Logging**: Structured logging with tracing

### Security Features

- Password hashing with Argon2
- HMAC-signed requests with timestamp + nonce enforcement
- Automatic disabling of keys that exceed failure thresholds
- Input validation and sanitization
- Per-key rate limiting and nonce replay protection
- Request logging and audit trails
- CORS support

## Troubleshooting

### Common Issues

1. **"JWT_SECRET is required"**
   - Ensure JWT_SECRET is set in environment or .env file

2. **"Invalid Lark credentials"**
   - Verify LARK_APP_ID and LARK_APP_SECRET are correct
   - Check Lark app permissions

3. **Database migration errors**
   - Ensure write permissions to database directory
   - Check SQLite installation

4. **Port already in use**
   - Change SERVER_PORT in environment
   - Kill existing process: `pkill lark_messager`

5. **Signature mismatch or timestamp outside window**
   - Ensure the client clock is within ±5 minutes of the server
   - Recalculate the HMAC using the documented canonical string
   - Use a fresh nonce per request

### Logs

- Application logs: `lark_messager.log`
- Docker logs: `docker-compose logs -f`

## Contributing

1. Fork the repository
2. Create feature branch: `git checkout -b feature-name`
3. Make changes and add tests
4. Run tests: `cargo test`
5. Submit pull request

## License

This project is licensed under the MIT License.
