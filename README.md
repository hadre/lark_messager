# Lark Messager

A Rust-based Lark (Feishu) messaging bot API service that provides secure message sending capabilities with unified user-scoped HMAC authentication.

## Features

- **Unified Auth**: User-scoped HMAC API keys with timestamp/nonce verification
- **Lark Integration**: Send messages to users and groups via Lark Bot API
- **Message Validation**: Verify recipient existence before sending
- **Comprehensive Logging**: Request logging, error tracking, and debug information
- **Docker Support**: Containerized deployment with Docker Compose
- **Database Support**: MySQL with automatic migrations
- **Rate Limiting Ready**: Architecture supports rate limiting implementation

## Quick Start

### Prerequisites

- Rust 1.75+ 
- Lark App credentials (App ID and App Secret)
- MySQL 8.0+ database

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd lark_messager
```

2. Copy environment configuration:
```bash
cp .env.example .env
```

3. Update `.env` with your Lark App credentials:
```env
LARK_APP_ID=your-lark-app-id
LARK_APP_SECRET=your-lark-app-secret
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
```

4. Build and run:
```bash
cargo build
cargo run
```

The server will start on `http://localhost:8080`. Keep it running so migrations can finish and management requests succeed.

5. Bootstrap an initial admin account (one-time):
```bash
cargo run --bin generate_credentials -- --user admin --password change_me_now
```
You can rerun this command with different credentials to provision additional users.

6. Log in and create an API key for signed requests:
```bash
# 6a. Obtain a JWT session token
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "change_me_now"}'

# 6b. Create an API key scoped to the logged-in user
curl -X POST http://localhost:8080/auth/api-keys \
  -H "Authorization: Bearer <jwt_token>" \
  -H "Content-Type: application/json" \
  -d '{"name": "local-dev", "rate_limit_per_minute": 30}'
```
Record the returned `secret` immediately; it is only shown once. Use the `/auth/api-keys` suite to list, disable, delete, or reset failure counts as needed.

### Docker Deployment

1. Build and start with Docker Compose:
```bash
docker-compose up -d
```

2. Check service health:
```bash
curl http://localhost:8080/health
```

## API Documentation

### Authentication

#### Session Authentication (JWT)
Use `/auth/login` with a username/password to obtain a short-lived JWT for managing API keys and configuration. Supply the token in `Authorization: Bearer <token>` when calling management endpoints.

#### Signed API Requests (HMAC)
Runtime calls to messaging endpoints must include the following headers:

- `X-Lark-Access-Key`: UUID of the API key
- `X-Lark-Timestamp`: UNIX seconds generated by the caller
- `X-Lark-Nonce`: unique nonce per request within the 5-minute window
- `X-Lark-Signature`: hex-encoded HMAC-SHA256 signature

The signature canonically signs the string:
```
<timestamp>
<nonce>
<HTTP_METHOD>
<path_with_query>
```
using the API key secret. Example with `openssl`:
```bash
TIMESTAMP=$(date -u +%s)
NONCE=$(uuidgen | tr 'A-Z' 'a-z')
CANONICAL="$TIMESTAMP
$NONCE
POST
/messages/send"
SIGNATURE=$(printf "%s" "$CANONICAL" | openssl dgst -sha256 -hmac "$API_KEY_SECRET" -hex | awk '{print $2}')
```
Requests older than 5 minutes or with duplicated nonces are rejected and increase the key's failure count. Exceeding the configured threshold automatically disables the key.

### Endpoints

#### Health Check
```bash
GET /health
```

#### Authentication
```bash
POST /auth/login                     # Obtain JWT session token
GET  /auth/api-keys                  # List API keys owned by the session user
POST /auth/api-keys                  # Create an API key for the session user
PATCH /auth/api-keys/{id}/status     # Enable or disable an API key
PATCH /auth/api-keys/{id}/rate-limit # Adjust per-minute rate limit
POST /auth/api-keys/{id}/reset-failures # Reset failure counter for an API key
DELETE /auth/api-keys/{id}           # Permanently delete an API key
GET  /auth/configs                   # Inspect authentication-related configs (admin only)
PATCH /auth/configs                  # Update authentication-related configs (admin only)
```

#### Messages
```bash
POST /messages/send                  # Send message to user (HMAC headers required)
POST /messages/send-group            # Send message to group (HMAC headers required)
POST /recipients/verify              # Verify recipient exists (HMAC headers required)
```

### Example Usage

#### Send Message with Signed Headers
```bash
TIMESTAMP=$(date -u +%s)
NONCE=$(uuidgen | tr 'A-Z' 'a-z')
CANONICAL="$TIMESTAMP
$NONCE
POST
/messages/send"
SIGNATURE=$(printf "%s" "$CANONICAL" | openssl dgst -sha256 -hmac "$API_KEY_SECRET" -hex | awk '{print $2}')

curl -X POST http://localhost:8080/messages/send \
  -H "X-Lark-Access-Key: $API_KEY_ID" \
  -H "X-Lark-Timestamp: $TIMESTAMP" \
  -H "X-Lark-Nonce: $NONCE" \
  -H "X-Lark-Signature: $SIGNATURE" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient": "user@example.com",
    "message": "Hello from Lark Messager!",
    "recipient_type": "email"
  }'
```

#### Verify Recipient
```bash
TIMESTAMP=$(date -u +%s)
NONCE=$(uuidgen | tr 'A-Z' 'a-z')
CANONICAL="$TIMESTAMP
$NONCE
POST
/recipients/verify"
SIGNATURE=$(printf "%s" "$CANONICAL" | openssl dgst -sha256 -hmac "$API_KEY_SECRET" -hex | awk '{print $2}')

curl -X POST http://localhost:8080/recipients/verify \
  -H "X-Lark-Access-Key: $API_KEY_ID" \
  -H "X-Lark-Timestamp: $TIMESTAMP" \
  -H "X-Lark-Nonce: $NONCE" \
  -H "X-Lark-Signature: $SIGNATURE" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient": "user@example.com",
    "recipient_type": "email"
  }'
```

## Configuration

### Environment Variables

| Variable | Description | Default | Required |
|----------|-------------|---------|----------|
| `DATABASE_URL` | MySQL database connection URL | `mysql://root:password@localhost:3306/lark_messager` | No |
| `JWT_SECRET` | JWT signing secret | - | Yes |
| `LARK_APP_ID` | Lark application ID | - | Yes |
| `LARK_APP_SECRET` | Lark application secret | - | Yes |
| `SERVER_HOST` | Server bind address | `127.0.0.1` | No |
| `SERVER_PORT` | Server port | `8080` | No |
| `LOG_LEVEL` | Logging level | `info` | No |
| `AUTO_MIGRATE` | Run migrations on startup | `true` | No |
| `API_KEY_LENGTH` | Generated API key length | `64` | No |

### Recipient Types

The service supports multiple recipient identification methods:

#### For Individual Messages (`/messages/send`)
- `user_id`: Lark user open_id (obtained from email/mobile lookup)
- `email`: Email address (automatically converted to open_id)
- `mobile`: Phone number (automatically converted to open_id)
- `auto`: Auto-detect based on format (default)

#### For Group Messages (`/messages/send-group`)
- `chat_id`: Group chat ID (oc_xxx, ou_xxx)
- `chat_name`: Group chat name (automatically converted to chat_id)
- `auto`: Auto-detect based on format (default)

## Development

### Running Tests

```bash
# Run all tests
cargo test

# Run specific test
cargo test test_login_success

# Run with output
cargo test -- --nocapture
```

### Database Setup

1. Create a MySQL database:
```sql
CREATE DATABASE lark_messager;
CREATE USER 'lark_user'@'%' IDENTIFIED BY 'lark_password';
GRANT ALL PRIVILEGES ON lark_messager.* TO 'lark_user'@'%';
FLUSH PRIVILEGES;
```

2. Database migrations are automatically applied on startup. Migration files are located in the `migrations/` directory.

Auth data lives in `auth_users` and `auth_api_keys`, while tunable thresholds are stored in `app_configs` (seeded with sensible defaults in `002_unified_auth.sql`).

### Adding New Features

1. Update models in `src/models.rs`
2. Add database operations in `src/database.rs`
3. Implement handlers in `src/handlers.rs`
4. Add routes in `src/routes.rs`
5. Write tests in `tests/`

## Architecture

### Core Components

- **Web Server**: Axum-based HTTP server
- **Authentication**: User-scoped HMAC API keys with JWT-backed management sessions
- **Database**: MySQL with SQLx ORM
- **Lark Client**: HTTP client for Lark Bot API
- **Logging**: Structured logging with tracing

### Security Features

- Password hashing with Argon2
- HMAC-signed requests with timestamp + nonce enforcement
- Automatic disabling of keys that exceed failure thresholds
- Input validation and sanitization
- Per-key rate limiting and nonce replay protection
- Request logging and audit trails
- CORS support

## Troubleshooting

### Common Issues

1. **"JWT_SECRET is required"**
   - Ensure JWT_SECRET is set in environment or .env file

2. **"Invalid Lark credentials"**
   - Verify LARK_APP_ID and LARK_APP_SECRET are correct
   - Check Lark app permissions

3. **Database migration errors**
   - Ensure write permissions to database directory
   - Check SQLite installation

4. **Port already in use**
   - Change SERVER_PORT in environment
   - Kill existing process: `pkill lark_messager`

5. **Signature mismatch or timestamp outside window**
   - Ensure the client clock is within Â±5 minutes of the server
   - Recalculate the HMAC using the documented canonical string
   - Use a fresh nonce per request

### Logs

- Application logs: `lark_messager.log`
- Docker logs: `docker-compose logs -f`

## Contributing

1. Fork the repository
2. Create feature branch: `git checkout -b feature-name`
3. Make changes and add tests
4. Run tests: `cargo test`
5. Submit pull request

## License

This project is licensed under the MIT License.